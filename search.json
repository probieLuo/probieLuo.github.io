[{"title":"文章评论使用gitalk报错","date":"2023-07-04T06:50:02.000Z","url":"/2023/07/04/%E6%96%87%E7%AB%A0%E8%AF%84%E8%AE%BA%E4%BD%BF%E7%94%A8gitgitalk%E6%8A%A5%E9%94%99/","tags":[["hexo","/tags/hexo/"],["gitalk","/tags/gitalk/"],["url解码编码","/tags/url%E8%A7%A3%E7%A0%81%E7%BC%96%E7%A0%81/"]],"categories":[["undefined",""]],"content":"前言本来想在我的博客上加入评论功能，看到Gitalk是基于GitHub Issue实现评论功能的，果断就用了，因为之前网上看到其他人评论系统因为服务商跑路而没了，Gitalk就不用担心这个原因了。 正文好了，说回正题，在配置Gitalk的时候发现有的文章能评论有的文章报错error: validation failed，然后搜了一下，发现是因为GitHub Issuelabel太长导致的无法评论，类似这样 这是因为url自动编码的原因，然后我的评论设置的通过GitHub Issuelabel路径展示每篇文章的评论，所以这肯定长度超标了，看了一圈解决方案，有个说把标签转md5的，有的居然统一设了同一个短label，我就在想有这么复杂吗，总之就是url编码太长,把url解码变短就行了嘛，下面是我的Gitalk配置，我这里是hexo框架搭建主题Kratos-Rebirth 总之，核心就是把url编码解码就行了:decodeURIComponent() 这个函数js内置的直接用就可以了。 要是想了解如何搭建个人博客或者搭建博客过程中遇到什么问题，欢迎下面留言交流。"},{"title":"C#关键字partial","date":"2023-07-04T05:23:58.000Z","url":"/2023/07/04/C-%E5%85%B3%E9%94%AE%E5%AD%97partial/","tags":[["C#","/tags/C/"]],"categories":[["C#","/categories/C/"]],"content":"前言partial是分部类型，可以将一个类、接口或结构、方法分成多个部分，便于管理。在编译时会将所有部分组合起来，与普通类并无多大区别，但需要注意累加效应。 分部类以下情况需要拆分类定义 处理大型项目时，使一个类分布于多个独立文件中可以让多位程序员同时对该类进行处理。 当使用自动生成的源文件时，你可以添加代码而不需要重新创建源文件。 Visual Studio 在创建Windows 窗体、Web 服务包装器代码等时会使用这种方法。 你可以创建使用这些类的代码，这样就不需要修改由Visual Studio生成的文件。 累加效应 分部类各个部分可以指定不同的基接口，最终类型将实现所有分部声明所列出的全部接口。 分部类编译时会对分部类型定义的属性进行合并 分部方法分部类或结构可以包含分部方法。 类的一个部分包含方法的签名。 可以在同一部分或另一部分中定义实现。 如果未提供该实现，则会在编译时删除方法以及对方法的所有调用。分部方法允许类的某个部分的实现者声明方法。 类的另一部分的实现者可以定义该方法。 在以下两个情形中，此方法很有用：生成样板代码的模板和源生成器。 模板代码：模板保留方法名称和签名，以使生成的代码可以调用方法。 这些方法遵循允许开发人员决定是否实现方法的限制。 如果未实现该方法，编译器会删除方法签名以及对该方法的所有调用。 调用该方法（包括调用中的任何参数计算结果）在运行时没有任何影响。 因此，分部类中的任何代码都可以随意地使用分部方法，即使未提供实现也是如此。 调用但不实现该方法不会导致编译时错误或运行时错误。 源生成器：源生成器提供方法的实现。 开发人员可以添加方法声明（通常由源生成器读取属性）。 开发人员可以编写调用这些方法的代码。 源生成器在编译过程中运行并提供实现。 在这种情况下，不会遵循不经常实现的分部方法的限制。 使用限制 partial 修饰符不可用于委托或枚举声明中。 同一个类型的各个部分必须有修饰符partial。 要成为同一类型的各个部分的所有分部类型定义都必须在同一程序集和同一模块（.exe 或 .dll 文件）中进行定义。 分部定义不能跨越多个模块。 你可以为已定义并实现的分部方法生成委托，但不能为已经定义但未实现的分部方法生成委托。 "},{"title":"Hello Blog","date":"2023-06-14T08:37:44.000Z","url":"/2023/06/14/Image/","tags":[["images","/tags/images/"]],"categories":[["undefined",""]],"content":"昨天看鱼友们写的博客，感觉挺酷的，自己也弄了个，也不知道写点啥，就放点图片吧。以后的话这里应该会记录一些自己的学习笔记，共勉。 Imagesscenery animation "},{"title":"测试","date":"2023-06-14T02:46:38.000Z","url":"/2023/06/14/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":[["git","/tags/git/"]],"categories":[["undefined",""]],"content":" 简介Git是分布式版本控制系统 分布式版本控制系统，重点在于分布。分布的含义不是说每台计算机上只留有版本库的一部分。恰恰相反，分布的含义是每台计算机上都还有一个完整的版本库。这个时候，你的修改仅仅需要提交给本地的版本库进行保存就可以了。 不同于集中式版本控制系统的“中央服务器”，分布式版本控制系统可以通过推送版本库，实现不同的计算机之间的版本共享。什么意思呢？就是说对于同一个文件A，如果两个人同时对A文件进行了修改，最新的版本应该都保存在各自的计算机中，想要实现协同开发，只需要将各自的最新版本库推送给对方，就可以得到最新的版本库了。 但是这里面有个问题，就是一个团队很大的情况下，大家都去修改，到底找谁同步版本库，不乱套了嘛。而且，大的开发项目也不是简单的两台计算机之间的版本互推就可以得到完整的版本库的。所以，分布式版本控制系统中通常也会有一台充当“中央服务器”的计算机，大家都把版本推送到这台计算机上，而需要同步的人只需同步这一台固定的计算机就可以。 所谓的分布式管理中的“中央服务器”是用来“交换意见”，或者说充当中介作用的。每一台计算机通过和这台固定的中介交换意见以后，都会拥有完整的版本库。 Windows安装Gitwindows上使用Git，可以从Git官网下载安装程序，默认安装。安装完成后找到Git Bash完成下列设置 Git是分布式版本控制系统，所以每个机器都需自报家门。 常用基本命令 git init 建立版本库 git add 把要提交的东西添加到暂存区。commit时将会把暂存区的内容提交。 git commit 把暂存区的所有内容提交到当前分支。 git branch 操作Git分支的命令 git clone 克隆远程存储库到本地（克隆的是整个远程库） git config 用来配置Git的相关参数 Git三个配置文件 仓库级的配置文件：在仓库的 .git&#x2F;.gitconfig，该配置文件只对所在的仓库有效。 全局配置文件：Mac 系统在 ~&#x2F;.gitconfig，Windows 系统在 C:\\Users&lt;用户名&gt;.gitconfig。 系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 &#x2F;usr&#x2F;local&#x2F;git）的 etc 文件夹中的 gitconfig。 git fetch 更新本地仓库 git log git merge 分支合并 git mv git pull 从远程仓库获取最新版本并合并到本地。 首先会执行 git fetch，然后执行 git merge，把获取的分支的 HEAD 合并到当前分支。 git push 把本地仓库的提交推送到远程仓库。 git remote 操作远程库。 git tag 操作标签的命令。 "},{"title":"Hello World","date":"2023-06-14T01:58:36.733Z","url":"/2023/06/14/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]