[{"title":"Docker基本使用","date":"2025-11-12T10:30:46.000Z","url":"/probieluo/posts/DockerUsage/","tags":[["Docker","/probieluo/tags/Docker/"]],"categories":[["开发工具","/probieluo/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"]],"content":"安装Ubuntu安装 更换镜像源输入以下命令测试下 它会以ubuntu15.10 镜像创建一个新容器（或者说镜像实例），然后在容器里执行 bin&#x2F;echo “Hello world”，然后输出结果。 这里由于我们新安装Docker，还没有ubuntu15.10 镜像，这个命令会去镜像仓库 Docker Hub 下载公共镜像。这时一般会出现 出现这种情况需要更换Docker镜像源修改或者新增/etc/docker/daemon.json 写入 重启 Docker 服务，使配置生效 输入以下命令 表示成功了 执行以下命令可以看到ubuntu的镜像 使用我们new .NET一个控制台应用发布 部署到Docker在项目根目录创建Dockerfile 构建镜像 sudo docker images可查看已安装的镜像列表 创建容器（镜像实例） sudo docker ps -a可查看所有容器的列表 管理容器使用 sudo docker start 命令启动容器，然后使用 sudo docker ps 命令仅显示正在运行的容器 连接到容器使用 sudo docker start 和 sudo docker attach 命令启动容器并查看输出流 删除容器 每次docker命令加sudo太麻烦可以执行下面命令 离线安装使用离线安装Docker下载 Docker 离线安装包 &#x3D;&gt; 拷贝到离线设备 &#x3D;&gt; 解压 离线导入 Docker 镜像下载 Docker 镜像 &#x3D;&gt; 加载离线镜像 "},{"title":"C#面试核心知识点详解","date":"2025-11-11T14:00:00.000Z","url":"/probieluo/posts/CSharp%E9%9D%A2%E8%AF%95%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/","tags":[["C#","/probieluo/tags/C/"],["面试","/probieluo/tags/%E9%9D%A2%E8%AF%95/"],["编程语言","/probieluo/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"]],"categories":[["开发技术","/probieluo/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"]],"content":"前言深入浅出讲解C#面试中的核心知识点，包括值类型与引用类型、泛型、委托事件、异步编程、LINQ等重要概念 值类型与引用类型 值类型：直接存储数据本身，如int、bool、struct、enum等，存储在栈（Stack）上（或作为引用类型的字段时存储在堆上）。 引用类型：储存数据的引用（内存地址），实际数据在堆（Heap）上，如string、class、array、delegate等。 区别： 赋值行为：值类型赋值时赋值数据本身；引用类型赋值时赋值时复制引用（指向同一堆内存）。 内存管理：值类型超出作用域自动释放；引用类型由GC（垃圾回收器）管理生命周期。 代码举例： 方法参数传递，值类型和引用类型的传递方式区别 值类型：方法内修改不会影响外部变量。 引用类型：默认按引用类型传递的引用地址，方法内部修改对象内容会影响外部（指向同一对象） 装箱（Boxing）和拆箱（Unboxing） 装箱：将值类型转换为引用类型（object或接口）的过程 过程：在堆上分配内存 → 复制值类型数据到堆 → 返回堆对象的引用 拆箱：将引用类型（装箱后的对象）转换回值类型的过程 过程：检查对象类型是否匹配 → 从堆中提取值 → 复制到栈上 性能影响 装箱和拆箱都涉及内存分配和复制操作，开销较大 频繁装箱会增加GC压力（堆上产生大量临时对象） 应尽量避免：使用泛型集合（如List&lt;T&gt;）代替非泛型集合（如ArrayList） 代码示例： 常见装箱场景 值类型赋值给object或接口变量 值类型作为参数传递给接受object的方法（如Console.WriteLine(123)） 值类型存入非泛型集合（ArrayList、Hashtable等） 接口和抽象类 接口：仅定义方法、属性、事件或索引器的签名（无实现）。Interface定义，成员默认public。 抽象类：可包含抽象成员和具体成员的类，不能实例化。abstract定义，成员可指定访问修饰符。 接口和抽象类区别 维度 接口 抽象类 继承方式 支持多继承（一个类可实现多个接口） 单继承（一个类只能继承一个抽象类） 成员实现 所有成员无实现（纯契约） 可混合抽象成员（无实现）和具体成员 访问修饰符 成员默认public，不可修改 成员可指定public&#x2F;protected等 构造函数 无构造函数 有构造函数（供派生类调用） 字段 不能包含字段（仅属性&#x2F;方法等） 可以包含字段 版本兼容 新增成员会导致所有实现类必须修改 可新增具体成员，不影响派生类 什么时候用接口？什么时候用抽象类？ 优先用接口场景： 需要继承多能力时 定义跨多个不相关类的通用功能（如IDisposable接口） 纯契约设计，不提供默认实现（如服务接口） 优先用抽象类场景： 多个相关类共享部分实现逻辑（提取公共代码） 需要定义字段或构造函数时 希望控制继承层次（单继承体系），且可能后续扩展具体方法 接口和抽象类在依赖注入中的应用场景 接口是依赖注入的核心，用于定义服务契约，实现依赖倒置（高层模块依赖抽象） 抽象类较少直接用于依赖注入，但若多个服务共享基础逻辑，可作为基类 泛型 什么是泛型？为什么使用泛型？ 定义：泛型是.NET 2.0 引入的特性，允许在定义类、接口、方法、委托时使用未指定的 “类型参数”，在使用时再指定具体类型（如 List&lt;T&gt; 中的 T 就是类型参数） 作用 类型安全：避免运行时类型转换错误（如非泛型 ArrayList 存储 object，需强制转换，可能抛 InvalidCastException） 性能优化：减少装箱 &#x2F; 拆箱操作（值类型存入非泛型集合时会装箱，取出时拆箱，泛型直接操作具体类型）。 代码复用：用一套逻辑支持多种类型（如 List&lt;int&gt;、List&lt;string&gt; 共享 List&lt;T&gt; 的实现）。 泛型类型参数的约束（Constraints）有哪些？如何使用？约束用于限制类型参数的范围，确保其满足特定条件（如必须是引用类型、必须有默认构造函数等）。常见约束： where T : class：T 必须是引用类型（类、接口、委托等）。 where T : struct：T 必须是值类型（int、struct 等，不包括 Nullable&lt;T&gt;）。 where T : new()：T 必须有公共无参构造函数（需放在其他约束最后）。 where T : 基类名：T 必须是指定基类或其派生类。 where T : 接口名：T 必须实现指定接口。 where T : U：T 必须是 U 的派生类型（泛型参数间的约束）。 示例： 泛型方法与泛型类的区别？ 泛型类：在类级别声明类型参数，类的所有成员（方法、属性等）可使用该参数（如 List&lt;T&gt;）。 泛型方法：在方法级别声明类型参数，仅该方法可用，可独立于类的泛型参数（即使类非泛型，也可定义泛型方法）。 泛型类型在运行时的表现（泛型类型的实例化）？ 值类型：对不同值类型的泛型实例（如 List&lt;int&gt;、List&lt;double&gt;），CLR 会生成不同的原生代码（因值类型大小不同）。 引用类型：对不同引用类型的泛型实例（如 List&lt;string&gt;、List&lt;object&gt;），CLR共享一套原生代码（因引用类型在内存中都是指针，大小相同）。 委托与事件 委托（Delegate）：委托是一种类型安全的函数指针，可以引用一个或多个具有相同签名的方法 定义：使用 delegate 关键字定义，指定返回类型和参数列表 特点： 类型安全：编译时检查方法签名是否匹配 支持多播：一个委托可以引用多个方法（通过 += 添加，-= 移除） 可以作为参数传递或作为返回值 常见内置委托： Action&lt;T&gt;：无返回值的委托（可带0-16个参数） Func&lt;T, TResult&gt;：有返回值的委托（可带0-16个参数） Predicate&lt;T&gt;：返回bool的委托（用于条件判断） 事件（Event）：事件是对委托的封装，用于实现发布-订阅模式 定义：使用 event 关键字修饰委托 特点： 只能在类内部触发（通过 Invoke 或 ?.Invoke()） 外部只能订阅（+=）或取消订阅（-=），不能直接赋值或触发 提供了更好的封装性，防止外部误触发事件 委托与事件的区别 委托是类型，事件是成员（事件是委托实例的包装器） 委托可被外部赋值（=）和调用，事件只能被订阅&#x2F;取消订阅 事件通常用于类之间的松耦合通信（如UI事件、观察者模式） 代码示例： 委托的应用场景 回调函数：如 LINQ 的 Where(x =&gt; x &gt; 10)、异步编程的回调 事件处理：UI 框架中的按钮点击、数据变更通知等 策略模式：动态选择算法（如排序策略） 链式调用：如中间件管道（ASP.NET Core 的 Use 方法） 匿名方法与 Lambda 表达式 匿名方法（Anonymous Method）：C# 2.0 引入的特性，用于内联定义委托的实现（无需单独定义方法） 语法：delegate (参数列表) { 方法体 } 特点： 可访问外部作用域的变量（形成闭包） 可省略参数列表（如果委托不需要参数） Lambda 表达式（Lambda Expression）：C# 3.0 引入的更简洁的匿名方法语法 语法： 表达式 Lambda：(参数) =&gt; 表达式（单行返回值） 语句 Lambda：(参数) =&gt; { 语句块 }（多行代码块） 特点： 更简洁：省略 delegate 关键字和返回类型 支持表达式树：可转换为 Expression&lt;Func&lt;T&gt;&gt; 类型（用于 LINQ to SQL 等场景） 广泛用于 LINQ、事件订阅、异步编程等 匿名方法 vs Lambda 表达式 维度 匿名方法 Lambda 表达式 语法简洁性 冗长（需 delegate 关键字） 简洁（仅需 =&gt; 符号） 表达式树 不支持 支持（可转换为 Expression&lt;T&gt;） 参数推断 需显式声明参数类型 可推断参数类型（如 x =&gt; x &gt; 5） 适用场景 已被 Lambda 取代（兼容旧代码） 现代 C# 的首选方式 代码示例： 闭包（Closure）的注意事项 Lambda 和匿名方法会捕获外部变量的引用（而非值） 如果在循环中使用 Lambda，需注意变量捕获的时机： Lambda 表达式的应用场景 LINQ 查询：var result = list.Where(x =&gt; x &gt; 10).Select(x =&gt; x * 2); 事件订阅：button.Click += (s, e) =&gt; Console.WriteLine(&quot;点击&quot;); 异步编程：await Task.Run(() =&gt; DoWork()); 函数式编程：高阶函数（接受或返回函数的函数） "},{"title":"Git常用命令","date":"2025-11-11T12:00:00.000Z","url":"/probieluo/posts/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":[["Git","/probieluo/tags/Git/"],["版本控制","/probieluo/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"]],"categories":[["开发工具","/probieluo/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"]],"content":" Git 是一个免费且开源的分布式版本控制系统，旨在以速度和效率处理从小型到大型项目的所有内容。它易于学习，体积小巧、性能极快。通过诸如低成本本地分支、方便的暂存区域和多种工作流程等特性，Git 超越了 Subversion、CVS、Perforce 和 ClearCase 等传统 SCM 工具。 🧭 什么是版本控制系统？版本控制系统（Version Control System, 简称 VCS）是一种用于记录文件内容变化的软件工具。它能够让多人协作开发同一个项目，跟踪每一次更改，随时恢复历史状态，比较不同版本差异，并有效防止数据丢失。 ✅ 简单理解：它是“代码的时间机器”。 ⚙️ 一、安装与配置下载与安装Git 下载地址：git-scm.com&#x2F;downloads下载安装包后，一路点击“下一步”完成安装。 配置用户信息打开 Git Bash，执行以下命令设置用户名与邮箱（全局配置）： 验证是否配置成功： 若只为当前仓库配置，则去掉 –global 参数： 检查单个仓库config 检查配置信息： 关联GitHub（SSH 方式） 生成 SSH 密钥 在命令行执行： 生成完成后，在路径： 可以看到 id_rsa（私钥） id_rsa.pub（公钥） 添加到 GitHub 进入： GitHub → Settings → SSH and GPG Keys → New SSH Key 把 id_rsa.pub 文件内容复制到 Key 中，Title 可随意填写。 测试是否成功 ⚙️ 二、GIT基本操作 命令 说明 git init 初始化 Git 仓库 git add README.md 添加文件到暂存区 git add . 添加当前目录所有文件到暂存区 git commit -m &quot;first commit&quot; 提交更改并记录说明 git branch -M master 强制重命名当前分支为 master git remote add origin git@github.com:probieLuo/xxx.git 添加远程仓库 git push -u origin master 推送代码到远程仓库并建立关联 git checkout main 切换分支main "},{"title":"你好，世界！","date":"2018-05-06T09:03:12.000Z","url":"/probieluo/posts/hello-world/","tags":[["欢迎","/probieluo/tags/%E6%AC%A2%E8%BF%8E/"]],"categories":[["全新体验","/probieluo/categories/%E5%85%A8%E6%96%B0%E4%BD%93%E9%AA%8C/"]],"content":"欢迎使用 Kratos : Rebirth 这个我们精心打造的 Hexo 主题！希望能在接下来的旅途中与您相伴，共同创造出更多难以忘怀的美好体验。"},{"title":"链接列表","date":"2025-09-30T14:43:02.000Z","url":"/probieluo/linklist-example/index.html","categories":[["undefined",""]]}]